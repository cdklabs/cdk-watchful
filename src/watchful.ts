import { CfnOutput, Aspects, Names } from 'aws-cdk-lib';
import * as apigw from 'aws-cdk-lib/aws-apigateway';
import * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';
import * as cloudwatch_actions from 'aws-cdk-lib/aws-cloudwatch-actions';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as ecs from 'aws-cdk-lib/aws-ecs';
import { ApplicationTargetGroup, TargetGroupBase } from 'aws-cdk-lib/aws-elasticloadbalancingv2';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as rds from 'aws-cdk-lib/aws-rds';
import * as sns from 'aws-cdk-lib/aws-sns';
import * as sns_subscriptions from 'aws-cdk-lib/aws-sns-subscriptions';
import * as sqs from 'aws-cdk-lib/aws-sqs';
import * as stepfunctions from 'aws-cdk-lib/aws-stepfunctions';
import { Construct } from 'constructs';
import { IWatchful, SectionOptions } from './api';
import { WatchApiGatewayOptions, WatchApiGateway } from './api-gateway';
import { WatchfulAspect, WatchfulAspectProps } from './aspect';
import { WatchDynamoTableOptions, WatchDynamoTable } from './dynamodb';
import { WatchEcsServiceOptions, WatchEcsService } from './ecs';
import { WatchService } from './ecs/service';
import { WatchTargetGroup } from './ecs/target-group';
import { WatchLambdaFunctionOptions, WatchLambdaFunction } from './lambda';
import { WatchRdsAuroraOptions, WatchRdsAurora } from './rds-aurora';
import { WatchStateMachineOptions, WatchStateMachine } from './state-machine';
import { SectionWidget } from './widget/section';

export interface WatchfulProps {
  /**
   * Email address to send alarms to.
   * @default - alarms are not sent to an email recipient.
   */
  readonly alarmEmail?: string;

  /**
   * SQS queue to send alarms to.
   * @default - alarms are not sent to an SQS queue.
   */
  readonly alarmSqs?: sqs.IQueue;

  /**
   * SNS topic to send alarms to.
   * @default - alarms are not sent to an SNS Topic.
   */
  readonly alarmSns?: sns.ITopic;

  /**
   * The name of the CloudWatch dashboard generated by Watchful.
   * @default - auto-generated
   */
  readonly dashboardName?: string;

  /**
   * ARNs of actions to perform when alarms go off. These actions are in
   * addition to email/sqs/sns.
   *
   * @default []
   *
   * You can use `alarmActions` instead as a strongly-typed alternative.
   */
  readonly alarmActionArns?: string[];

  /**
   * CloudWatch alarm actions to perform when alarms go off. These actions are
   * in addition to email/sqs/sns.
   */
  readonly alarmActions?: cloudwatch.IAlarmAction[];

  /**
   * Whether to generate CloudWatch dashboards
   * @default true
   */
  readonly dashboard?: boolean;
}

export class Watchful extends Construct implements IWatchful {
  private readonly dash?: cloudwatch.Dashboard;
  private readonly alarmTopic?: sns.ITopic;
  private readonly alarmActions: cloudwatch.IAlarmAction[];
  private createdAlarmCount = 0;

  constructor(scope: Construct, id: string, props: WatchfulProps = { }) {
    super(scope, id);

    this.alarmActions = [
      ...(props.alarmActionArns ?? []).map((alarmActionArn) => ({ bind: () => ({ alarmActionArn }) })),
      ...(props.alarmActions ?? []),
    ];

    if ((props.alarmEmail || props.alarmSqs) && !props.alarmSns) {
      this.alarmTopic = new sns.Topic(this, 'AlarmTopic', { displayName: 'Watchful Alarms' });
    }

    if (props.alarmSns) {
      this.alarmTopic = props.alarmSns;
    }

    if (props.alarmEmail && this.alarmTopic) {
      this.alarmTopic.addSubscription(
        new sns_subscriptions.EmailSubscription(props.alarmEmail),
      );
    }

    if (props.alarmSqs && this.alarmTopic) {
      this.alarmTopic.addSubscription(
        new sns_subscriptions.SqsSubscription(
          // sqs.Queue.fromQueueArn(this, 'AlarmQueue', props.alarmSqs)
          props.alarmSqs,
        ),
      );
    }

    if (props.dashboard === false && props.dashboardName) {
      throw new Error('Dashboard name is provided but dashboard creation is disabled');
    }
    if (props.dashboard !== false) {
      this.dash = new cloudwatch.Dashboard(this, 'Dashboard', { dashboardName: props.dashboardName });

      new CfnOutput(this, 'WatchfulDashboard', {
        value: linkForDashboard(this.dash),
      });
    }

  }

  public addWidgets(...widgets: cloudwatch.IWidget[]) {
    this.dash?.addWidgets(...widgets);
  }

  public addAlarm(alarm: cloudwatch.IAlarm) {
    const alarmWithAction = hasAlarmAction(alarm) ? alarm : new cloudwatch.CompositeAlarm(this, `Created Alarm ${this.createdAlarmCount++}`, {
      alarmRule: cloudwatch.AlarmRule.fromAlarm(alarm, cloudwatch.AlarmState.ALARM),
    });
    if (this.alarmTopic) {
      alarmWithAction.addAlarmAction(new cloudwatch_actions.SnsAction(this.alarmTopic));
    }

    alarmWithAction.addAlarmAction(...this.alarmActions);
  }

  public addSection(title: string, options: SectionOptions = {}) {
    this.addWidgets(new SectionWidget({
      titleLevel: 1,
      titleMarkdown: title,
      quicklinks: options.links,
    }));
  }

  public watchScope(scope: Construct, options?: WatchfulAspectProps) {
    const aspect = new WatchfulAspect(this, options);
    Aspects.of(scope).add(aspect);
  }

  public watchDynamoTable(title: string, table: dynamodb.Table, options: WatchDynamoTableOptions = {}) {
    return new WatchDynamoTable(this, Names.uniqueId(table), {
      title,
      watchful: this,
      table,
      ...options,
    });
  }

  public watchApiGateway(title: string, restApi: apigw.RestApi, options: WatchApiGatewayOptions = {}) {
    return new WatchApiGateway(this, Names.uniqueId(restApi), {
      title, watchful: this, restApi, ...options,
    });
  }

  public watchLambdaFunction(title: string, fn: lambda.Function, options: WatchLambdaFunctionOptions = {}) {
    return new WatchLambdaFunction(this, Names.uniqueId(fn), {
      title, watchful: this, fn, ...options,
    });
  }

  public watchStateMachine(title: string, stateMachine: stepfunctions.StateMachine, options: WatchStateMachineOptions = {}) {
    return new WatchStateMachine(this, Names.uniqueId(stateMachine), {
      title, watchful: this, stateMachine, ...options,
    });
  }

  public watchRdsAuroraCluster(title: string, cluster: rds.DatabaseCluster, options: WatchRdsAuroraOptions = {}) {
    return new WatchRdsAurora(this, Names.uniqueId(cluster), {
      title, watchful: this, cluster, ...options,
    });
  }
  public watchFargateEcs(title: string, fargateService: ecs.FargateService, targetGroup: ApplicationTargetGroup,
    options: WatchEcsServiceOptions = {}) {

    return new WatchEcsService(this, Names.uniqueId(fargateService), {
      title, watchful: this, fargateService, targetGroup, ...options,
    });
  }
  public watchEc2Ecs(title: string, ec2Service: ecs.Ec2Service, targetGroup: ApplicationTargetGroup, options: WatchEcsServiceOptions = {}) {
    return new WatchEcsService(this, Names.uniqueId(ec2Service), {
      title, watchful: this, ec2Service, targetGroup, ...options,
    });
  }
  public watchFargateService(title: string, service: ecs.FargateService, options: WatchEcsServiceOptions = {}) {
    return new WatchService(this, Names.uniqueId(service), {
      title, watchful: this, service, ...options,
    });
  }
  public watchApplicationTargetGroup(title: string, targetGroup: TargetGroupBase, options: WatchEcsServiceOptions = {}) {
    return new WatchTargetGroup(this, Names.uniqueId(targetGroup), {
      title, watchful: this, targetGroup, ...options,
    });
  }
}

function linkForDashboard(dashboard: cloudwatch.Dashboard) {
  const cfnDashboard = dashboard.node.defaultChild as cloudwatch.CfnDashboard;
  return `https://console.aws.amazon.com/cloudwatch/home?region=${dashboard.stack.region}#dashboards:name=${cfnDashboard.ref}`;
}

function hasAlarmAction(alarm: cloudwatch.IAlarm): alarm is cloudwatch.IAlarm & { addAlarmAction: (...actions: cloudwatch.IAlarmAction[]) => void } {
  return 'addAlarmAction' in alarm;
}

